{"author":"Jonathan Brown <jbrown@bluedroplet.com>","title":"AbstractBlobStore","fileName":"contracts/abstract_blobstore.sol","name":"AbstractBlobStore","abi":[{"constant":true,"inputs":[{"name":"blobId","type":"bytes20"}],"name":"getFlags","outputs":[{"name":"flags","type":"bytes4"}],"payable":false,"type":"function"},{"constant":true,"inputs":[{"name":"blobId","type":"bytes20"}],"name":"getExists","outputs":[{"name":"exists","type":"bool"}],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"blobId","type":"bytes20"}],"name":"transferEnable","outputs":[],"payable":false,"type":"function"},{"constant":true,"inputs":[{"name":"blobId","type":"bytes20"}],"name":"getAllRevisionBlockNumbers","outputs":[{"name":"blockNumbers","type":"uint256[]"}],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"flags","type":"bytes4"},{"name":"contents","type":"bytes"}],"name":"create","outputs":[{"name":"blobId","type":"bytes20"}],"payable":false,"type":"function"},{"constant":true,"inputs":[{"name":"blobId","type":"bytes20"}],"name":"getRetractable","outputs":[{"name":"retractable","type":"bool"}],"payable":false,"type":"function"},{"constant":true,"inputs":[{"name":"blobId","type":"bytes20"}],"name":"getUpdatable","outputs":[{"name":"updatable","type":"bool"}],"payable":false,"type":"function"},{"constant":true,"inputs":[{"name":"blobId","type":"bytes20"}],"name":"getRevisionCount","outputs":[{"name":"revisionCount","type":"uint256"}],"payable":false,"type":"function"},{"constant":true,"inputs":[],"name":"getContractId","outputs":[{"name":"","type":"bytes12"}],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"blobId","type":"bytes20"}],"name":"transferDisable","outputs":[],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"flagsNonce","type":"bytes32"},{"name":"contents","type":"bytes"}],"name":"createWithNonce","outputs":[{"name":"blobId","type":"bytes20"}],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"blobId","type":"bytes20"}],"name":"setEnforceRevisions","outputs":[],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"blobId","type":"bytes20"}],"name":"setNotRetractable","outputs":[],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"blobId","type":"bytes20"},{"name":"contents","type":"bytes"}],"name":"updateLatestRevision","outputs":[],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"blobId","type":"bytes20"}],"name":"retractLatestRevision","outputs":[],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"blobId","type":"bytes20"},{"name":"contents","type":"bytes"}],"name":"createNewRevision","outputs":[{"name":"revisionId","type":"uint256"}],"payable":false,"type":"function"},{"constant":true,"inputs":[{"name":"blobId","type":"bytes20"}],"name":"getTransferable","outputs":[{"name":"transferable","type":"bool"}],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"blobId","type":"bytes20"},{"name":"recipient","type":"address"}],"name":"transfer","outputs":[],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"blobId","type":"bytes20"}],"name":"setNotTransferable","outputs":[],"payable":false,"type":"function"},{"constant":true,"inputs":[{"name":"blobId","type":"bytes20"}],"name":"getInfo","outputs":[{"name":"flags","type":"bytes4"},{"name":"owner","type":"address"},{"name":"revisionCount","type":"uint256"},{"name":"blockNumbers","type":"uint256[]"}],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"blobId","type":"bytes20"}],"name":"retract","outputs":[],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"blobId","type":"bytes20"}],"name":"setNotUpdatable","outputs":[],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"blobId","type":"bytes20"}],"name":"disown","outputs":[],"payable":false,"type":"function"},{"constant":true,"inputs":[{"name":"blobId","type":"bytes20"}],"name":"getEnforceRevisions","outputs":[{"name":"enforceRevisions","type":"bool"}],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"blobId","type":"bytes20"},{"name":"contents","type":"bytes"}],"name":"restart","outputs":[],"payable":false,"type":"function"},{"constant":true,"inputs":[{"name":"blobId","type":"bytes20"}],"name":"getOwner","outputs":[{"name":"owner","type":"address"}],"payable":false,"type":"function"}],"bin":"","opcodes":"","source":"pragma solidity ^0.4.4;\n\n\n/**\n * @title AbstractBlobStore\n * @author Jonathan Brown <jbrown@bluedroplet.com>\n * @dev Contracts must be able to interact with blobs regardless of which BlobStore contract they are stored in, so it is necessary for there to be an abstract contract that defines an interface for BlobStore contracts.\n */\ncontract AbstractBlobStore {\n\n    /**\n     * @dev Creates a new blob. It is guaranteed that different users will never receive the same blobId, even before consensus has been reached. This prevents blobId sniping. Consider createWithNonce() if not calling from another contract.\n     * @param flags Packed blob settings.\n     * @param contents Contents of the blob to be stored.\n     * @return blobId Id of the blob.\n     */\n    function create(bytes4 flags, bytes contents) external returns (bytes20 blobId);\n\n    /**\n     * @dev Creates a new blob using provided nonce. It is guaranteed that different users will never receive the same blobId, even before consensus has been reached. This prevents blobId sniping. This method is cheaper than create(), especially if multiple blobs from the same account end up in the same block. However, it is not suitable for calling from other contracts because it will throw if a unique nonce is not provided.\n     * @param flagsNonce First 4 bytes: Packed blob settings. The parameter as a whole must never have been passed to this function from the same account, or it will throw.\n     * @param contents Contents of the blob to be stored.\n     * @return blobId Id of the blob.\n     */\n    function createWithNonce(bytes32 flagsNonce, bytes contents) external returns (bytes20 blobId);\n\n    /**\n     * @dev Create a new blob revision.\n     * @param blobId Id of the blob.\n     * @param contents Contents of the new revision.\n     * @return revisionId The new revisionId.\n     */\n    function createNewRevision(bytes20 blobId, bytes contents) external returns (uint revisionId);\n\n    /**\n     * @dev Update a blob's latest revision.\n     * @param blobId Id of the blob.\n     * @param contents Contents that should replace the latest revision.\n     */\n    function updateLatestRevision(bytes20 blobId, bytes contents) external;\n\n    /**\n     * @dev Retract a blob's latest revision. Revision 0 cannot be retracted.\n     * @param blobId Id of the blob.\n     */\n    function retractLatestRevision(bytes20 blobId) external;\n\n    /**\n     * @dev Delete all a blob's revisions and replace it with a new blob.\n     * @param blobId Id of the blob.\n     * @param contents Contents that should be stored.\n     */\n    function restart(bytes20 blobId, bytes contents) external;\n\n    /**\n     * @dev Retract a blob.\n     * @param blobId Id of the blob. This blobId can never be used again.\n     */\n    function retract(bytes20 blobId) external;\n\n    /**\n     * @dev Enable transfer of the blob to the current user.\n     * @param blobId Id of the blob.\n     */\n    function transferEnable(bytes20 blobId) external;\n\n    /**\n     * @dev Disable transfer of the blob to the current user.\n     * @param blobId Id of the blob.\n     */\n    function transferDisable(bytes20 blobId) external;\n\n    /**\n     * @dev Transfer a blob to a new user.\n     * @param blobId Id of the blob.\n     * @param recipient Address of the user to transfer to blob to.\n     */\n    function transfer(bytes20 blobId, address recipient) external;\n\n    /**\n     * @dev Disown a blob.\n     * @param blobId Id of the blob.\n     */\n    function disown(bytes20 blobId) external;\n\n    /**\n     * @dev Set a blob as not updatable.\n     * @param blobId Id of the blob.\n     */\n    function setNotUpdatable(bytes20 blobId) external;\n\n    /**\n     * @dev Set a blob to enforce revisions.\n     * @param blobId Id of the blob.\n     */\n    function setEnforceRevisions(bytes20 blobId) external;\n\n    /**\n     * @dev Set a blob to not be retractable.\n     * @param blobId Id of the blob.\n     */\n    function setNotRetractable(bytes20 blobId) external;\n\n    /**\n     * @dev Set a blob to not be transferable.\n     * @param blobId Id of the blob.\n     */\n    function setNotTransferable(bytes20 blobId) external;\n\n    /**\n     * @dev Get the id for this BlobStore contract.\n     * @return Id of the contract.\n     */\n    function getContractId() external constant returns (bytes12);\n\n    /**\n     * @dev Check if a blob exists.\n     * @param blobId Id of the blob.\n     * @return exists True if the blob exists.\n     */\n    function getExists(bytes20 blobId) external constant returns (bool exists);\n\n    /**\n     * @dev Get info about a blob.\n     * @param blobId Id of the blob.\n     * @return flags Packed blob settings.\n     * @return owner Owner of the blob.\n     * @return revisionCount How many revisions the blob has.\n     * @return blockNumbers The block numbers of the revisions.\n     */\n    function getInfo(bytes20 blobId) external constant returns (bytes4 flags, address owner, uint revisionCount, uint[] blockNumbers);\n\n    /**\n     * @dev Get all a blob's flags.\n     * @param blobId Id of the blob.\n     * @return flags Packed blob settings.\n     */\n    function getFlags(bytes20 blobId) external constant returns (bytes4 flags);\n\n    /**\n     * @dev Determine if a blob is updatable.\n     * @param blobId Id of the blob.\n     * @return updatable True if the blob is updatable.\n     */\n    function getUpdatable(bytes20 blobId) external constant returns (bool updatable);\n\n    /**\n     * @dev Determine if a blob enforces revisions.\n     * @param blobId Id of the blob.\n     * @return enforceRevisions True if the blob enforces revisions.\n     */\n    function getEnforceRevisions(bytes20 blobId) external constant returns (bool enforceRevisions);\n\n    /**\n     * @dev Determine if a blob is retractable.\n     * @param blobId Id of the blob.\n     * @return retractable True if the blob is blob retractable.\n     */\n    function getRetractable(bytes20 blobId) external constant returns (bool retractable);\n\n    /**\n     * @dev Determine if a blob is transferable.\n     * @param blobId Id of the blob.\n     * @return transferable True if the blob is transferable.\n     */\n    function getTransferable(bytes20 blobId) external constant returns (bool transferable);\n\n    /**\n     * @dev Get the owner of a blob.\n     * @param blobId Id of the blob.\n     * @return owner Owner of the blob.\n     */\n    function getOwner(bytes20 blobId) external constant returns (address owner);\n\n    /**\n     * @dev Get the number of revisions a blob has.\n     * @param blobId Id of the blob.\n     * @return revisionCount How many revisions the blob has.\n     */\n    function getRevisionCount(bytes20 blobId) external constant returns (uint revisionCount);\n\n    /**\n     * @dev Get the block numbers for all of a blob's revisions.\n     * @param blobId Id of the blob.\n     * @return blockNumbers Revision block numbers.\n     */\n    function getAllRevisionBlockNumbers(bytes20 blobId) external constant returns (uint[] blockNumbers);\n\n}\n","abiDocs":[{"constant":true,"inputs":[{"name":"blobId","type":"bytes20","description":"Id of the blob."}],"name":"getFlags","outputs":[{"name":"flags","type":"bytes4"}],"payable":false,"type":"function","details":"Get all a blob's flags.","return":"flags Packed blob settings.","signature":"getFlags(bytes20)","signatureHash":"01fd89a4"},{"constant":true,"inputs":[{"name":"blobId","type":"bytes20","description":"Id of the blob."}],"name":"getExists","outputs":[{"name":"exists","type":"bool"}],"payable":false,"type":"function","details":"Check if a blob exists.","return":"exists True if the blob exists.","signature":"getExists(bytes20)","signatureHash":"08b7c13b"},{"constant":false,"inputs":[{"name":"blobId","type":"bytes20","description":"Id of the blob."}],"name":"transferEnable","outputs":[],"payable":false,"type":"function","details":"Enable transfer of the blob to the current user.","signature":"transferEnable(bytes20)","signatureHash":"12511c14"},{"constant":true,"inputs":[{"name":"blobId","type":"bytes20","description":"Id of the blob."}],"name":"getAllRevisionBlockNumbers","outputs":[{"name":"blockNumbers","type":"uint256[]"}],"payable":false,"type":"function","details":"Get the block numbers for all of a blob's revisions.","return":"blockNumbers Revision block numbers.","signature":"getAllRevisionBlockNumbers(bytes20)","signatureHash":"22057bc7"},{"constant":false,"inputs":[{"name":"flags","type":"bytes4","description":"Packed blob settings."},{"name":"contents","type":"bytes","description":"Contents of the blob to be stored."}],"name":"create","outputs":[{"name":"blobId","type":"bytes20"}],"payable":false,"type":"function","details":"Creates a new blob. It is guaranteed that different users will never receive the same blobId, even before consensus has been reached. This prevents blobId sniping. Consider createWithNonce() if not calling from another contract.","return":"blobId Id of the blob.","signature":"create(bytes4,bytes)","signatureHash":"30a24abd"},{"constant":true,"inputs":[{"name":"blobId","type":"bytes20","description":"Id of the blob."}],"name":"getRetractable","outputs":[{"name":"retractable","type":"bool"}],"payable":false,"type":"function","details":"Determine if a blob is retractable.","return":"retractable True if the blob is blob retractable.","signature":"getRetractable(bytes20)","signatureHash":"3c335b0e"},{"constant":true,"inputs":[{"name":"blobId","type":"bytes20","description":"Id of the blob."}],"name":"getUpdatable","outputs":[{"name":"updatable","type":"bool"}],"payable":false,"type":"function","details":"Determine if a blob is updatable.","return":"updatable True if the blob is updatable.","signature":"getUpdatable(bytes20)","signatureHash":"3df91162"},{"constant":true,"inputs":[{"name":"blobId","type":"bytes20","description":"Id of the blob."}],"name":"getRevisionCount","outputs":[{"name":"revisionCount","type":"uint256"}],"payable":false,"type":"function","details":"Get the number of revisions a blob has.","return":"revisionCount How many revisions the blob has.","signature":"getRevisionCount(bytes20)","signatureHash":"3ef87414"},{"constant":true,"inputs":[],"name":"getContractId","outputs":[{"name":"","type":"bytes12"}],"payable":false,"type":"function","details":"Get the id for this BlobStore contract.","return":"Id of the contract.","signature":"getContractId()","signatureHash":"4788cabf"},{"constant":false,"inputs":[{"name":"blobId","type":"bytes20","description":"Id of the blob."}],"name":"transferDisable","outputs":[],"payable":false,"type":"function","details":"Disable transfer of the blob to the current user.","signature":"transferDisable(bytes20)","signatureHash":"47bdb7f4"},{"constant":false,"inputs":[{"name":"flagsNonce","type":"bytes32","description":"First 4 bytes: Packed blob settings. The parameter as a whole must never have been passed to this function from the same account, or it will throw."},{"name":"contents","type":"bytes","description":"Contents of the blob to be stored."}],"name":"createWithNonce","outputs":[{"name":"blobId","type":"bytes20"}],"payable":false,"type":"function","details":"Creates a new blob using provided nonce. It is guaranteed that different users will never receive the same blobId, even before consensus has been reached. This prevents blobId sniping. This method is cheaper than create(), especially if multiple blobs from the same account end up in the same block. However, it is not suitable for calling from other contracts because it will throw if a unique nonce is not provided.","return":"blobId Id of the blob.","signature":"createWithNonce(bytes32,bytes)","signatureHash":"6d1da953"},{"constant":false,"inputs":[{"name":"blobId","type":"bytes20","description":"Id of the blob."}],"name":"setEnforceRevisions","outputs":[],"payable":false,"type":"function","details":"Set a blob to enforce revisions.","signature":"setEnforceRevisions(bytes20)","signatureHash":"9243e088"},{"constant":false,"inputs":[{"name":"blobId","type":"bytes20","description":"Id of the blob."}],"name":"setNotRetractable","outputs":[],"payable":false,"type":"function","details":"Set a blob to not be retractable.","signature":"setNotRetractable(bytes20)","signatureHash":"976b01c0"},{"constant":false,"inputs":[{"name":"blobId","type":"bytes20","description":"Id of the blob."},{"name":"contents","type":"bytes","description":"Contents that should replace the latest revision."}],"name":"updateLatestRevision","outputs":[],"payable":false,"type":"function","details":"Update a blob's latest revision.","signature":"updateLatestRevision(bytes20,bytes)","signatureHash":"9e65c7e5"},{"constant":false,"inputs":[{"name":"blobId","type":"bytes20","description":"Id of the blob."}],"name":"retractLatestRevision","outputs":[],"payable":false,"type":"function","details":"Retract a blob's latest revision. Revision 0 cannot be retracted.","signature":"retractLatestRevision(bytes20)","signatureHash":"a7e93e87"},{"constant":false,"inputs":[{"name":"blobId","type":"bytes20","description":"Id of the blob."},{"name":"contents","type":"bytes","description":"Contents of the new revision."}],"name":"createNewRevision","outputs":[{"name":"revisionId","type":"uint256"}],"payable":false,"type":"function","details":"Create a new blob revision.","return":"revisionId The new revisionId.","signature":"createNewRevision(bytes20,bytes)","signatureHash":"a84c5330"},{"constant":true,"inputs":[{"name":"blobId","type":"bytes20","description":"Id of the blob."}],"name":"getTransferable","outputs":[{"name":"transferable","type":"bool"}],"payable":false,"type":"function","details":"Determine if a blob is transferable.","return":"transferable True if the blob is transferable.","signature":"getTransferable(bytes20)","signatureHash":"aa5d4719"},{"constant":false,"inputs":[{"name":"blobId","type":"bytes20","description":"Id of the blob."},{"name":"recipient","type":"address","description":"Address of the user to transfer to blob to."}],"name":"transfer","outputs":[],"payable":false,"type":"function","details":"Transfer a blob to a new user.","signature":"transfer(bytes20,address)","signatureHash":"b06df18e"},{"constant":false,"inputs":[{"name":"blobId","type":"bytes20","description":"Id of the blob."}],"name":"setNotTransferable","outputs":[],"payable":false,"type":"function","details":"Set a blob to not be transferable.","signature":"setNotTransferable(bytes20)","signatureHash":"b971b4e5"},{"constant":true,"inputs":[{"name":"blobId","type":"bytes20","description":"Id of the blob."}],"name":"getInfo","outputs":[{"name":"flags","type":"bytes4"},{"name":"owner","type":"address"},{"name":"revisionCount","type":"uint256"},{"name":"blockNumbers","type":"uint256[]"}],"payable":false,"type":"function","details":"Get info about a blob.","return":"flags Packed blob settings.owner Owner of the blob.revisionCount How many revisions the blob has.blockNumbers The block numbers of the revisions.","signature":"getInfo(bytes20)","signatureHash":"ba15e52e"},{"constant":false,"inputs":[{"name":"blobId","type":"bytes20","description":"Id of the blob. This blobId can never be used again."}],"name":"retract","outputs":[],"payable":false,"type":"function","details":"Retract a blob.","signature":"retract(bytes20)","signatureHash":"cf7315c6"},{"constant":false,"inputs":[{"name":"blobId","type":"bytes20","description":"Id of the blob."}],"name":"setNotUpdatable","outputs":[],"payable":false,"type":"function","details":"Set a blob as not updatable.","signature":"setNotUpdatable(bytes20)","signatureHash":"d0c24e93"},{"constant":false,"inputs":[{"name":"blobId","type":"bytes20","description":"Id of the blob."}],"name":"disown","outputs":[],"payable":false,"type":"function","details":"Disown a blob.","signature":"disown(bytes20)","signatureHash":"d6ca8ccb"},{"constant":true,"inputs":[{"name":"blobId","type":"bytes20","description":"Id of the blob."}],"name":"getEnforceRevisions","outputs":[{"name":"enforceRevisions","type":"bool"}],"payable":false,"type":"function","details":"Determine if a blob enforces revisions.","return":"enforceRevisions True if the blob enforces revisions.","signature":"getEnforceRevisions(bytes20)","signatureHash":"dba1ac3d"},{"constant":false,"inputs":[{"name":"blobId","type":"bytes20","description":"Id of the blob."},{"name":"contents","type":"bytes","description":"Contents that should be stored."}],"name":"restart","outputs":[],"payable":false,"type":"function","details":"Delete all a blob's revisions and replace it with a new blob.","signature":"restart(bytes20,bytes)","signatureHash":"e0a70811"},{"constant":true,"inputs":[{"name":"blobId","type":"bytes20","description":"Id of the blob."}],"name":"getOwner","outputs":[{"name":"owner","type":"address"}],"payable":false,"type":"function","details":"Get the owner of a blob.","return":"owner Owner of the blob.","signature":"getOwner(bytes20)","signatureHash":"e487eb58"}]}
